<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      RMarcus &middot; It's all Frank's Fault!
    
  </title>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    
    ga('create', 'UA-53336646-1', 'auto');
    ga('require', 'displayfeatures');
    ga('send', 'pageview');
    
  </script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="/blog//public/css/poole.css">
  <link rel="stylesheet" href="/blog//public/css/syntax.css">
  <link rel="stylesheet" href="/blog//public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="/blog//public/css/rmarcus.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blog//public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/blog//public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/blog//atom.xml">

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    }
    });
  </script>
  <script type="text/javascript"
	  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  <!--<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/angularjs/1.3.0-beta.10/angular.min.js"></script>-->
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.4/angular.min.js"></script>

  <script src="/blog/assets/angular-apps.js"></script>
  <script type="text/javascript" src="/blog/assets/conn4/conn4ctrl.js"></script>
  <script src="/blog/assets/vulcan/vulcan.js"></script>
  <script src="/blog/assets/vulcan/app.js"></script>


</head>


  <body ng-app="angularApps">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/blog/">
          RMarcus
        </a>
      </h1>
      <p class="lead">The musings and work of Ryan Marcus, a graduate student at Brandeis University and the Los Alamos National Laboratory.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/blog/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/blog/pubs/">Portfolio</a>
          
        
      
        
      
        
      
        
          
        
      
        
          
        
      

            <a class="sidebar-nav-item" href="/blog"></a>

      <!-- <a class="sidebar-nav-item" href="/archive/v2.0.0.zip">Download</a>
      <a class="sidebar-nav-item" href="">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.0.0</span> -->
      <a class="sidebar-nav-item" href="http://twitter.com/RyanMarcus">Twitter</a>
      <a class="sidebar-nav-item" href="https://keybase.io/rmarcus">Keybase</a>
    </nav>

    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2015/09/02/vulcan.html">
        Vulcan: A JavaScript Automated Proof System
      </a>
    </h1>

    <span class="post-date">02 Sep 2015</span>

    <p>Mathematicians have been trying to figure out how to <a href="https://en.wikipedia.org/wiki/Automated_theorem_proving">get computers to write proofs for a long time</a>. One of the earliest (dating back to the 1960s) attempts to do so was a logical rule called <a href="https://en.wikipedia.org/wiki/Resolution_%28logic%29">resolution</a>.</p>

<p>I created <a href="https://www.npmjs.com/package/vulcan">Vulcan, an NPM package</a> that implements a resolution-based automated proof system. Below is a in-browser demo I created with <a href="https://angularjs.org/">AngularJS</a> and <a href="http://browserify.org/">Browserify</a>. You can use symbols <code>A-Z</code> as variables that can be either true or false, and any of the following operations: <code>-&gt;</code> (implication), <code>&lt;-&gt;</code> (equivalence), <code>!</code> (negation), <code>&amp;</code> (conjunction), and <code>|</code> (disjunction).</p>

<p>Enter some information into the knowledge base, enter a query, and click “prove” to see a proof (if one exists).</p>

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />

<div>
  <ng-include src="'/blog/assets/vulcan/vulcan.html'"></ng-include>
</div>

<hr />

<p>This certainly <a href="http://blog.metawrap.com/2008/07/21/javascript-finite-state-machinetheorem-prover/">isn’t the first JavaScript implementation of a theorem prover</a>, nor is it even <a href="https://github.com/leanprover/lean.js">the most powerful</a>. It does, however, demonstrate the ability of a very simple system to come up with (in exponential time), a proof of <em>any provable statement in propositional calculus</em>.</p>

<p>But how does it work? Once again, you can find an excellent introduction in <a href="http://www.cs.berkeley.edu/~russell/">Stuart Russell</a> and <a href="http://norvig.com">Peter Norvig’s</a> <a href="http://www.amazon.com/Artificial-Intelligence-Modern-Approach-Edition/dp/0136042597">book</a>. But understanding the system really only requires two fundamental ideas about symbolic logic:</p>

<ol>
  <li>That any expression in propositional logic can be written in <strong>conjunctive normal form</strong></li>
  <li>That logical resolution is <strong>sound and complete</strong>.</li>
</ol>

<h3 id="conjunctive-normal-form">Conjunctive normal form</h3>

<p>The first point is the simplest. We say that a sentence of propositional logic is in conjunctive normal form if it is a series of other sentences combined via conjunction, such that each of the combined sentences is a disjunction of sentence symbols or negations of sentence symbols. In other words, a sentence is in conjunctive normal form if it is an AND of ORs. For example,</p>

<script type="math/tex; mode=display">A \land (B \lor D) \land C</script>

<p>… is in conjunctive normal form, as is:</p>

<script type="math/tex; mode=display">A \land (B \lor \lnot C \lor D) \land C</script>

<p>However, this sentence is not in conjunctive normal form:</p>

<script type="math/tex; mode=display">A \land (B \lor C \land E) \lor D</script>

<p>Nor is this one:</p>

<script type="math/tex; mode=display"> (A \to B) \land C</script>

<p>The fact that <script type="math/tex">(A \to B) \land C</script> is not in CNF (conjunctive normal form) seems problematic. Surely, any sufficiently powerful proof system should be able to handle implications. However, we can transform this expression into one that is in CNF using a simple trick: we replace the implication <script type="math/tex">A \to B</script> with <script type="math/tex">\lnot A \lor B</script>.</p>

<script type="math/tex; mode=display"> (A \to B) \land C \Rightarrow (\lnot A \lor B) \land C</script>

<p>Our new expression, <script type="math/tex">(\lnot A \lor B) \land C</script>, is in CNF. In fact, there is a sequence of logical rules that can be applied to any expression to convert it into CNF. Norvig and Russell give an excellent description that can be found in other places on the Internet, and I’ll produce my own explanation here.</p>

<ol>
  <li>Remove bijections: <script type="math/tex">A \leftrightarrow B \Rightarrow (A \to B) \land (B \to A)</script>.</li>
  <li>Replace any implications: <script type="math/tex">A \to B \Rightarrow \lnot A \lor B</script></li>
  <li>Move nots inwards via DeMorgan’s rule:
    <ul>
      <li>Not over and: <script type="math/tex"> \lnot (A \land B) \Rightarrow (\lnot A \lor \lnot B) </script></li>
      <li>Not over or: <script type="math/tex"> \lnot (A \lor B) \Rightarrow (\lnot A \land \lnot B) </script></li>
    </ul>
  </li>
  <li>Eliminate double negation: <script type="math/tex"> \lnot \lnot A \Rightarrow A </script></li>
  <li>Distribute ors over ands: <script type="math/tex"> (A \land B) \lor C \Rightarrow (C \lor A) \land (C \lor B)</script></li>
</ol>

<p>If you don’t believe that this simple algorithm will convert any sentence into CNF, try out a few examples. But this algorithm is not the easiest way to understand why any sentence in propositional logic can be converted into CNF. It’s helpful to remember that two sentences are equivalent if and only if they agree in every model. In other words, imagine you have two sentences, <script type="math/tex"> \alpha </script> and <script type="math/tex"> \beta </script>, composed of the symbols A, B, and C. You can say that <script type="math/tex"> \alpha = \beta </script> if you can plug in any value for A, B, and C and get the same final result for both <script type="math/tex">\alpha</script> and <script type="math/tex">\beta</script>.</p>

<p>Let’s take <script type="math/tex"> \alpha = (A \to (B \lor C)) </script>, and <script type="math/tex"> \beta = \lnot (A \land \lnot B \land \lnot C)</script> and test to see if they are equivalent by building a truth table.</p>

<table>
<tr>
<th>A</th><th>B</th><th>C</th><th>$$\alpha$$</th><th>$$\beta$$</th>
</tr>
<tr><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr>
<tr><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td></tr>
<tr><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td></tr>
<tr><td>T</td><td>F</td><td>F</td><td>F</td><td>F</td></tr>
<tr><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td></tr>
<tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td></tr>
<tr><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td></tr>
<tr><td>F</td><td>F</td><td>F</td><td>T</td><td>T</td></tr>

</table>

<p>Quite an exhausting process, but it works. We can see that <script type="math/tex"> \alpha = \beta </script>. The important consequence here is this: if we can construct a sentence with the same truth table as <script type="math/tex"> \alpha </script>, we can construct a sentence that is equivalent to <script type="math/tex">\alpha</script>.</p>

<p>So let’s think about how to construct a new sentence <script type="math/tex"> \gamma </script> that will be equivalent to <script type="math/tex"> \alpha </script> but also in CNF. Think of <script type="math/tex"> \gamma </script> as a bunch of clauses linked together by conjunctions. So, whenever <script type="math/tex"> \alpha </script> is false, we need to make sure that at least one of the clauses in <script type="math/tex"> \gamma </script> is false – that’ll make sure that all of <script type="math/tex"> \gamma </script> is false.</p>

<p>For every row in the truth table that ends in false, add a clause to <script type="math/tex"> \gamma </script> that is a conjunction of each sentence symbol, but negate the sentence symbol if that symbol is “false” in the table. For <script type="math/tex"> \alpha </script>, we have only one row in the truth table where the result is false. So we’ll have only one clause in <script type="math/tex"> \gamma </script>. That clause will be a disjunction of:</p>

<ul>
  <li>the negation of A, because A is false in that row of the truth table</li>
  <li>B, because B is true in that row</li>
  <li>C, because C is true in that row.</li>
</ul>

<p>So finally, we get <script type="math/tex"> \gamma = \lnot A \lor B \lor C </script>, which is equivalent to <script type="math/tex"> \alpha </script> and in CNF. If you don’t believe me, try a truth table or <a href="http://www.wolframalpha.com/input/?i=CNF+of+%28A+implies+%28B+or+C%29%29+">try WolframAlpha</a>. Now we have an algorithm for taking a truth table to a new sentence that will be in CNF.</p>

<p>Let’s try another example. Let <script type="math/tex"> \sigma = A \leftrightarrow B </script>. We’ll write out a truth table for <script type="math/tex"> \sigma </script> and then convert it to CNF.</p>

<table>
<tr>
<th>A</th><th>B</th><th>$$\sigma$$</th>
</tr>

<tr><td>T</td><td>T</td><td>T</td></tr>
<tr><td>T</td><td>F</td><td>F</td></tr>
<tr><td>F</td><td>T</td><td>F</td></tr>
<tr><td>F</td><td>F</td><td>T</td></tr>

</table>

<p>Since <script type="math/tex">\sigma</script> is false in two rows, we’ll have to build clauses from both of them. For the seoncd row, we get the clause <script type="math/tex"> A \lor \lnot B </script>. From the third row, we get <script type="math/tex"> \lnot A \lor B </script>. Putting the clauses together gives us <script type="math/tex"> (A \lor \lnot B) \land (\lnot A \lor B)</script>. That’s equivalent to <script type="math/tex"> \sigma </script>, which you can verify with a truth table or with <a href="http://www.wolframalpha.com/input/?i=CNF+of++%28A+equivalent+B%29">WolframAlpha</a>.</p>

<p>Hopefully you’re now significantly convinced that, given any sentence in propositional logic, there’s an equivalent sentence in CNF. The next critical component is <a href="https://en.wikipedia.org/wiki/Resolution_%28logic%29"><strong>logical resolution</strong></a>.</p>

<h3 id="resolution">Resolution</h3>

<p>Resolution is an interesting trick with some very useful properties. It can be stated as follows:</p>

<script type="math/tex; mode=display">\frac{A \lor B \lor C, \quad E \lor \lnot B \lor F}{A \lor C \lor E \lor F}</script>

<p>If you’ve never seen this notation before, it just means that if you are given the two sentences on top as true, then you can deduce that the sentence on the bottom is true as well. For resolution specifically, if you have two disjunctions with a complementary symbol (a symbol that is negated in one disjunction but not in the other), you can remove that symbol from both sentences and combine the two sentences with another disjunction.</p>

<p>It possible to prove that resolution is both sound (meaning that a deduction made by resolution will always be correct) and complete (meaning that any sentence that can be deduced can be deduced by resolution). The second property – completeness – is rather amazing. You might find it interesting to <a href="http://www.mathcs.duq.edu/simon/Fall04/notes-6-20/node3.html">read through a proof that explains why</a>.</p>

<p>So how do we take advantage of resolution to create a proof system? Notice that the inputs and the output of resolution are conjunctions – meaning a string of (possibly negated) symbols linked together by ORs. Since we can convert every statement in our knowledge base to CNF, we can separate out each of the disjunctions into different statements and combine them in different ways with resolution. Since resolution is sound, we know that any combination of two clauses in our knowledge base will be valid. Since resolution is complete, we know that any fact that can be inferred from our knowledge base can be inferred via resolution.</p>

<p>Now, given a knowledge base <script type="math/tex">KB</script> and a query <script type="math/tex">Q</script>, how do we find out if <script type="math/tex">Q</script> is true, given <script type="math/tex">KB</script>? To be more specific, we want to know if <script type="math/tex">Q</script> is semantically entailed by <script type="math/tex">KB</script>. Written formally: <script type="math/tex">KB \vDash Q</script>. By the <a href="https://en.wikipedia.org/wiki/G%C3%B6del's_completeness_theorem">completeness theorem</a>, we know that <script type="math/tex">KB \vDash Q</script> if and only if <script type="math/tex">Q</script> can be syntactically generated from <script type="math/tex">KB</script> using some sound method <script type="math/tex">m</script>: <script type="math/tex">KB \vdash_m Q</script>.</p>

<script type="math/tex; mode=display">KB \vDash Q \leftrightarrow \exists m (KB \vdash_m Q)</script>

<p>Let’s call our resolution method <script type="math/tex">r</script>. Since resolution is complete, we know that any semantically true sentence entailed by <script type="math/tex">KB</script> can be syntactically derived via <script type="math/tex">r</script>. In other words, we know that:</p>

<script type="math/tex; mode=display">KB \vDash Q \to KB \vdash_r Q</script>

<p>And, since <script type="math/tex">r</script> is sound, we know that any sentence derived via <script type="math/tex">r</script> from <script type="math/tex">KB</script> will also be entailed by <script type="math/tex">KB</script>. In other words, we have:</p>

<script type="math/tex; mode=display">KB \vdash_r Q \to KB \vDash Q</script>

<p>Combining these two gives us:</p>

<script type="math/tex; mode=display">KB \vDash Q \leftrightarrow KB \vdash_r Q</script>

<p>At this point, you might think an acceptable algorithm would be to take your knowledge base and apply resolution over and over again until you either find all possible sentences or you find <script type="math/tex">Q</script>. The problem here is that all sentences of propositional logic can be stated in infinitely many finite ways (there are infinitely many ways to express any sentence using only finitely many symbols). You might think you could solve this problem by simply converting each step into CNF. The problem with that is that CNF representations are not unique. Example:</p>

<script type="math/tex; mode=display">P \land (Q \lor A) == (A \lor Q) \land P</script>

<p>Even if you were to generate unique CNF statements by deriving the CNF from the truth table at each step, such an approach would require the proof system to build larger and larger clauses (until reaching <script type="math/tex">Q</script>). Ideally, we want to make things smaller and smaller. So instead of searching for <script type="math/tex">Q</script>, we’ll add <script type="math/tex">\lnot Q</script> to the knowledge base and then search for <code>false</code>. If you think about it, this is equivalent to <a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum"><em>reductio ad absurdum</em></a>, or proof by contradiction. If by assuming that our query is false we can produce a contradiction, then it must be the case that our query is true.</p>

<p>Let’s formalize that a little bit. Essentially, our statement is:</p>

<script type="math/tex; mode=display">KB \vDash Q \leftrightarrow (KB \cup \lnot Q) \mbox{ is unsatisfiable}</script>

<p>This is equivalent to the <a href="https://en.wikipedia.org/wiki/Deduction_theorem">deduction theorem</a>. A nice way to think of this is:</p>

<blockquote>
  <p>A statement can be proven from a knowledge base if and only if the negation of that statement combined with the knowledge base produces a contradiction. In other words, a statement is provable from a knowledge base only if the union of the knowledge base and the negation of the statement is unsatisfiable.</p>
</blockquote>

<p>So, if we show that <script type="math/tex">KB \cup \lnot Q</script> is unsatisfiable, we’ve shown that <script type="math/tex">KB \vDash Q</script>. This gives us the following algorithm:</p>

<ol>
  <li>Convert <script type="math/tex">KB</script> into CNF, and split up each sentence into clauses</li>
  <li>Assume <script type="math/tex">\lnot Q</script></li>
  <li>Apply resolution to every pair of clauses until either…
    <ul>
      <li>(a) no more clauses can be derived, meaning that there is no proof of <script type="math/tex">Q</script> from <script type="math/tex">KB</script>. If there were a proof, that would imply that there existed some <script type="math/tex">m</script> such that <script type="math/tex">KB \vdash_m Q</script>, but since we know resolution is complete and sound, it must be the case that such an <script type="math/tex">m</script> is not sound.</li>
      <li>(b) we derive an “empty clause”, or false. In other words, we find a contradiction. The existence of a contradiction is enough to prove that <script type="math/tex">KB \cup \lnot Q</script> is unsatisfiable, since it proves that you’ll always get <code>false</code> no matter what model you use. You’ve proven <script type="math/tex">Q</script> by contradiction.</li>
    </ul>
  </li>
</ol>

<p>The correctness of this algorithm has some interesting consequences. For example, try a knowledge base of <script type="math/tex">P</script> and <script type="math/tex">\lnot P</script>. That’s a contradiction. Then, ask the system to prove <script type="math/tex">A</script>, a symbol we know absolutely nothing about. The system will resolve <script type="math/tex">P</script> and <script type="math/tex">\lnot P</script> to false, and suggest that a contradiction has been reached from the knowledge base <script type="math/tex">P \land \lnot P \land A</script>. So have we proven <script type="math/tex">A</script> from <script type="math/tex">P \land \lnot P</script>?</p>

<p>Well, it turns out that we have! In fact, any conclusion follows from a contradiction. This is called <a href="https://en.wikipedia.org/wiki/Principle_of_explosion">the principle of explosion</a>, which can be stated as:</p>

<script type="math/tex; mode=display">\{ \nu, \lnot \nu \} \vdash \psi</script>

<p>Think of it this way. Consider a true statement like “the sky is blue.” We’ll call that <script type="math/tex">B</script>. Consider another statement, “the Easter Bunny is real.” We’ll call that <script type="math/tex">E</script>. We know that the statement <script type="math/tex">B \lor E</script> is true because <script type="math/tex">B</script> is true. However, let’s say for some reason we knew that the sky was blue and not blue, in other words, we know that <script type="math/tex">B \land \lnot B</script> was somehow true. Since we know <script type="math/tex">B \lor E</script> is true, and we know <script type="math/tex">\lnot B</script> is true, we can use resolution to deduce <script type="math/tex">E</script>:</p>

<script type="math/tex; mode=display">\frac{B \lor E, \quad \lnot B}{E}</script>

<p>So we’ve shown that <script type="math/tex">\{ B \lor E, B \land \lnot B \} \vdash_r E</script>. Since resolution (<script type="math/tex">r</script>) is sound, we know that <script type="math/tex">\{ B \lor E, B \land \lnot B \} \vDash E</script>. This isn’t so ridiculous when we say it out loud:</p>

<blockquote>
  <p>If the sky isn’t blue, the Easter Bunny is real.</p>
</blockquote>

<p>So it’s a good thing that our system finds that <script type="math/tex">A</script> is entailed by <script type="math/tex">P \land \lnot P</script>. If it didn’t, it wouldn’t be complete!</p>

<p>You might’ve noticed that the line numbers of each statement in the generated proofs aren’t sequential. That’s because the proof is generated via resolution, and only the relevant clauses are displayed at the end. Since what we’re trying to prove is that <script type="math/tex">KB \cup \lnot Q</script> is unsatisfiable, we’re essentially solving a limited case of the <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">boolean satisfiability problem</a>, which is <code>NP-complete</code>. That means there could be quite a few steps! If you put a lot of data into the knowledge base and ask a tough question, it might take your browser quite a while to come with an answer!</p>

<p>One more interesting tidbit: the initial state of the demo shows  how <a href="https://en.wikipedia.org/wiki/Modus_ponens">modus ponens</a> is really just a special case of resolution. Since we know that resolution is sound and complete, all sound logical inference rules are a special case of resolution. We also know that resolution is a subset of any complete inference rule, and we know that resolution is equivalent to any sound and complete inference rule. It’s reassuring to know that truth works the same way no matter what.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2014/12/23/connect4.html">
        A JavaScript Connect Four AI
      </a>
    </h1>

    <span class="post-date">23 Dec 2014</span>

    <p>Might I interest you in a rousing game of <a href="http://en.wikipedia.org/wiki/Connect_Four">Connect Four</a>? You and the computer take turns dropping discs into one of the seven colums below. The goal is to get four pieces of your color in a row (vertically, diagonally, or horizontally).</p>

<link rel="stylesheet" href="/blog/assets/conn4/conn4.css" />

<div>
  <div class="conn4" ng-controller="ConnFourCtrl">
    <div class="info">
      <div>Winner: <span ng-hide="winner">none yet...</span><span ng-show="winner">Player {{winner}}</span></div>
      <div>Draw: <span ng-hide="draw">no</span><span ng-show="draw">yes</span></div>
    </div>
    <div class="thinking">
      <img src="/blog/assets/conn4/ajax-loader.gif" ng-show="thinking" />
    </div>
    
    <svg width="240" height="180">
      <rect width="100%" height="100%" style="fill: yellow;" />
      <g ng-repeat="row in board" transform="translate(30, {{ ($index + 1) * 25 }})">
	<circle ng-repeat="col in row track by $index" cx="{{ $index * 30 }}" cy="0" r="11" class="hlc" ng-show="isOver[$index]" />
	<circle ng-repeat="col in row track by $index" cx="{{ $index * 30 }}" cy="0" r="10" stroke="black" ng-class="col" ng-click="move($index)" ng-mouseover="over($index)" ng-mouseleave="leave($index)" />
      </g>
    </svg>
    
    
    <div class="ai">
      <form class="form-horizontal" role="form">
	<label for="movesAhead">Moves to to think ahead</label>
	<input type="integer" class="movesAhead" id="movesAhead" ng-model="look_ahead" />
      </form>
    </div>
    
  </div>
</div>

<p>That’s an <a href="https://angularjs.org">AngularJS</a> powered Connect Four AI that was originally written in C and then compiled to JavaScript using <a href="https://github.com/kripken/emscripten/wiki">Emscripten</a>. It runs the actual AI in a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage">web worker</a> to prevent your browser from locking up.</p>

<p>It was implemented using techniques from <a href="http://www.cs.berkeley.edu/~russell/">Stuart Russell</a> and <a href="http://norvig.com">Peter Norvig’s</a> excellent book, <a href="http://www.amazon.com/Artificial-Intelligence-Modern-Approach-Edition/dp/0136042597">Artificial Intelligence: A Modern Approach (3rd Edition)</a>. These techniques might not create the best Connect Four AI possible (in fact, <a href="/blog/assets/conn4/thesis.pdf">Victor Allis’ thesis shows how to create a provably-unbeatable AI</a>), but it can still do pretty well! The code (in C, Python, and JavaScript) is available <a href="http://github.org/RyanMarcus/connect4">on GitHub</a>.</p>

<p>The main idea behind the AI is <a href="http://en.wikibooks.org/wiki/Artificial_Intelligence/Search/Adversarial_search/Minimax_Search">adversarial search</a>. Think of all the possible games of Connect Four represented as a tree. The root of the tree is the empty board. The second tier of the tree represents all the possible moves that can be made by the first player. The third tier of the tree represents all the possible moves that can be made by the second player.</p>

<p>A small subset of the tree (for a small game board) might look like this:</p>

<p><img src="/blog/assets/conn4/tree2.png" alt="Small tree" /></p>

<p>Imagine expanding the tree all the way down to the bottom, where the leaf nodes are “terminal” states – states where one player has won the game, or there is a draw. In order to make moves, the AI applies a <a href="http://en.wikipedia.org/wiki/Minimax">minimax strategy</a>. In other words, the AI assumes that its opponent will always play optimally, and thus tries to minimize the maximum gain of its opponent.</p>

<p>This tree is really big. The branching factor is approximately seven, and the depth of the tree could be as high as 42. So, while the the <a href="http://en.wikipedia.org/wiki/K-ary_tree">perfect tree formula</a> would tell us that there are <script type="math/tex">\frac{7^{43} - 1}{6} \approx 3 \mbox{ undecillion}</script> boards, some smart mathematicians have figured out that there are “only” around <a href="http://oeis.org/A212693">4 trillion different boards</a>. That’s still way too many to examine.</p>

<p>Thankfully, we can use a technique called <a href="http://en.wikipedia.org/wiki/Alpha–beta_pruning">alpha-beta pruning</a>. The idea is pretty simple: do not bother searching branches that would either:</p>

<ul>
  <li>require our opponent to make a detrimental move (to get an outcome less than the outcome they could get if they played optimally)</li>
  <li>or, require us to make a move that was less advantageous than another move we could make</li>
</ul>

<p>Now, this is a hand wavey oversimplification of how the process actually works. I suggest you read the chapters in Russell and Norvig, or fuss through the Wikipedia page, to get a better understanding. </p>

<p>In the average case, alpha-beta pruning reduces the number of nodes we need to evaluate from <script type="math/tex">O(b^d)</script> to <script type="math/tex">O(b^{\frac{3d}{4}})</script>. This brings us from 4 trillion boards to around 2.7 billion boards. A pretty good drop – but still not enough for us to enumerate.</p>

<p>Next, we employ a heuristic function. Since we can’t reach the bottom of the tree, we’ll go down a certain depth and then make some kind of guess as to whether or not the board we are evaluating is a winning or losing board. I used a very simple heuristic: the number of possible four-in-a-rows. The computer would calculate how many ways it could win using alignments present in the current board, and then subtract the number of ways the computer’s opponent could win.</p>

<p>Now, the computer will exhaustively evaluate the tree to a certain depth (the number of moves to “think ahead”) and then use a heuristic to evaluate that board. Eventually, as the end of the game draws near, the computer finds winning or losing states within the prescribed depth, and plays perfectly. The hope is that the heuristic function can guide the AI to a winnable position. It seems to work pretty well – if you can beat it, try increasing the number of moves to think ahead. It’ll make it slow down, but it’ll get exponentially more difficult. </p>

<p>Oh – there’s one more complication. A lot of the boards that you encounter when going down the tree are duplicates (there is more than one way to get to a state). To avoid recomputing the desirability of these boards, we store them in a hash table.</p>

<p>It also looks like writing this type of AI is homework for AI classes at <a href="http://www.cs.cornell.edu/courses/CS2110/2014sp/assignments/a4/A4ConnectFour.pdf">Cornell</a>,  <a href="http://www.ccs.neu.edu/home/eclip5e/classes/csu520/">Northeastern</a>, and <a href="https://www.cs.purdue.edu/homes/cs190m/fall08/projects/project4/">Purdue</a>. I could only find <a href="http://simulationcorner.net/index.php?page=connectfour">one other Javascript Connect Four AI</a>, which moves substantially faster than mine, but is easily defeated (which is exactly the behavior one would expect). </p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2014/10/05/dirty-json-parser.html">
        A Dirty JSON Parser
      </a>
    </h1>

    <span class="post-date">05 Oct 2014</span>

    <p>I’ve written a <a href="http://github.com/RyanMarcus/dirty-json">parser that does its best to parse invalid and malformed JSON</a>. It is written in JavaScript, and is <a href="https://www.npmjs.org/package/dirty-json">available on NPM</a>. There’s also <a href="http://rmarcus.info/dirty-json">an online demo</a>.</p>

<h2 id="why">Why?</h2>

<p>Recently, I had the unfortunate job of parsing some malformed JSON. This particular JSON had a lot of embedded HTML and newlines, and looked something like this:</p>

<pre><code>{ "key": "&lt;div class="item"&gt;an item
with newlines &lt;span class="attrib"&gt; and embedded
&lt;/span&gt;html&lt;/div&gt;",
  "key2": "&lt;div class="item"&gt;..."
}
</code></pre>

<p>Since this was a very large JSON file, I did not want to correct it by hand. I noticed that some of the other JSON files I had to parse were also malformed, so I began to make a list of common JSON mistakes I’d seen.</p>

<ul>
  <li>Non-escaped quotes inside of strings (<code>"some "string" here"</code> instead of <code>"some \"string\" here"</code>)</li>
  <li>Decimal numbers without a leading zero (<code>.5</code> instead of <code>0.5</code>)</li>
  <li>Newlines inside of keys (<code>"some \n text"</code> instead of <code>"some \\n text"</code>)</li>
  <li>Single quotes used instead of double quotes (<code>{'key': true}</code> instead of <code>{"key": true}</code>)</li>
  <li>Non-quoted object keys (<code>{key: true}</code> instead of <code>{"key": true}</code>)</li>
</ul>

<p>Some of these errors made the JSON ambiguous, but generally a human being could see what the JSON was “supposed” to be. Of course, no parser will be able to correctly disambiguate ambiguous JSON all the time, but I thought it was worth a try.</p>

<p>The result is a hand-written <a href="http://en.wikipedia.org/wiki/LL_parser"><code>LR(1)</code></a> parser that can handle JSON with a mix of the above errors. The parsed result will be a JavaScript object, but it might not always be the JavaScript object one expects. You can play around with <a href="http://rmarcus.info/dirty-json">the demo that I wrote to investigate yourself</a>.</p>

<p>I have spent no time optimizing the parser. In fact, it checks every rule whenever it finds a match regardless of the current terminal. So it’s probably pretty slow.</p>

<p>While I’m pretty sure that this parser will correctly handle all valid JSON (you can investigate my test cases in the <a href="http://github.com/RyanMarcus/dirty-json">GitHub repo</a>), I’m not completely convinced. This parser should probably only be used in one-time-use programs that absolutely need to handle malformed JSON.</p>

<p>If you find a bug (or an interesting use case), let me know via <a href="http://github.com/RyanMarcus/dirty-json">the GitHub repo</a> or <a href="http://twitter.com/RyanMarcus">Twitter</a>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2014/05/09/rdtheory.html">
        rdtheory.js: relational database algorithms in JavaScript
      </a>
    </h1>

    <span class="post-date">09 May 2014</span>

    <p>While reviewing <a href="http://www.amazon.com/Fundamentals-Database-Systems-6th-Edition/dp/0136086209">my database theory textbook</a>, I stumbled across a few algorithms for <a href="http://en.wikipedia.org/wiki/Database_normalization">relational schema decomposition and database normalization</a>. Aside from <a href="https://code.google.com/p/oneschema/">a dead project on Google Code</a> and <a href="http://uisacad5.uis.edu/cgi-bin/mcrem2/database_design_tool.cgi">a buggy and apparently closed-source implementation hosted at the University of Illinois</a>, I couldn’t really find any implementations or libraries implementing these algorithms.</p>

<p>So, I created <a href="http://bitbucket.org/RyanMarcus/rdtheory/">rdtheory.js</a> and <a href="http://ryanmarcus.bitbucket.org/schemata/">a small 3NF decomposition tool</a>. Neither are particularly polished or documented, but the library itself contains several tests. It is entirely synchronous, which could be a problem for very large schemes. At some point I might rewrite it with <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">promises</a>.</p>

<p>There are a few examples on the <a href="https://bitbucket.org/RyanMarcus/rdtheory/">BitBucket page</a>, but working through an example might be useful. Consider a relation with the following attributes:</p>

<ul>
  <li>First name [latex]F[/latex]</li>
  <li>Last name [latex]L[/latex]</li>
  <li>Email address [latex]E[/latex]</li>
  <li>Home address [latex]A[/latex]</li>
  <li>ZIP Code [latex]Z[/latex]</li>
  <li>Manager [latex]M[/latex]</li>
  <li>Years with company [latex]Y[/latex]</li>
  <li>Pay [latex]P[/latex]</li>
</ul>

<p>We can represent this relation as [latex]R[/latex]:</p>

<script type="math/tex; mode=display">R = \left\{ F, L, E, A, Z, M, Y, P \right\}</script>

<p>Next, let’s consider the semantics of the information stored in \(R\). In order to do so, it is helpful to remember the definition of a <a href="http://en.wikipedia.org/wiki/Functional_dependency">functional dependency</a>. We say that the set of attributes \(Y \in R\) functionally depends on another set of attributes \(X \in R\) if and only if every pair of rows in \(R\) that match on the attributes \(X\) also match on the attributes \(Y\). In other words, if \(X = \{A\}\) and \(Y = \{Z\}\), then we would say that one’s ZIP code functionally depends on one’s home address if and only if any two individuals with the same home address also have the same ZIP code. We write this functional dependency as \(X \to Y\). We can also say that \(X\) <em>determines</em> \(Y\). </p>

<p>For our example, let’s assume the following set of functional dependencies:</p>

<p>An employee’s first and last name determines their email address:</p>

<script type="math/tex; mode=display">\left\{F, L\right\} \to \left\{E\right\}</script>

<p>An employee’s first and last name determines their home address:</p>

<script type="math/tex; mode=display">\left\{F, L\right\} \to \left\{A\right\}</script>

<p>An employee’s home address determines their ZIP code:</p>

<script type="math/tex; mode=display">\left\{A\right\} \to \left\{Z\right\}</script>

<p>An employee’s email address determines their manager:</p>

<script type="math/tex; mode=display">\left\{E\right\} \to \left\{M\right\}</script>

<p>An employee’s years of service and their manager determines their pay:</p>

<script type="math/tex; mode=display">\left\{M, Y\right\} \to \left\{P \right\}</script>

<p>Now, as database programmers, we could simply create one table with each attribute in \(R\) as a column. But we know better! With our relation \(R\) and all these functional dependencies, we can use various algorithms and theorems from <a href="http://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> to create a <a href="http://en.wikipedia.org/wiki/Third_normal_form">3NF decomposition</a>.</p>

<p>Using <a href="http://ryanmarcus.bitbucket.org/schemata/">the tool I developed and linked above</a>, we can decompose \(R\) without computing minimal covers ourselves.</p>

<p><img src="/blog//assets/rdtheory_decomp.png" alt="A screenshot of the tool" /></p>

<p>From the tool, we can see that our universal relation \(R\) was not in 3NF. The tool suggests a decomposition of \(R\) into five relations, and conveniently marks the keys of each new relation with boldface. We can formally represent this decomposition as:</p>

<script type="math/tex; mode=display">R_1 = \left\{\underline{E}, M\right\}</script>

<script type="math/tex; mode=display">R_2 = \left\{E, \underline{F}, A, \underline{L}\right\}</script>

<script type="math/tex; mode=display">R_3 = \left\{\underline{A}, Z\right\}</script>

<script type="math/tex; mode=display">R_4 = \left\{\underline{M}, P, \underline{Y}\right\}</script>

<script type="math/tex; mode=display">R_5 = \left\{\underline{F}, \underline{L}, \underline{Y}\right\}</script>

<script type="math/tex; mode=display"> R_1 \cup R_2 \cup R_3 \cup R_4 \cup R_5 = R </script>

<p>Now, we can create five tables instead of one. The algorithm used also ensures that the decomposition preserves all dependencies and is a loseless join decomposition.</p>

<p>Happy normalizing!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2013/07/01/fallthrough-sort.html">
        Fallthrough Sort: Quickly Sorting Small Sets
      </a>
    </h1>

    <span class="post-date">01 Jul 2013</span>

    <p>In many applications, such as a <a href="http://en.wikipedia.org/wiki/Median_filter">median filter</a>, we want to sort a small ([latex]n &lt; 30[/latex]) set of numbers. In the case of the median filter, we are only concerned with sorting sets of one exact size – if this is the case, one can generate an optimal <a href="http://en.wikipedia.org/wiki/Sorting_network">sorting network</a> using a tool like <a href="http://pages.ripco.net/~jgamble/nw.html">this one</a> to create a provably-unbeatable solution.</p>

<p>However, often we want to be able to sort sets of varying size that are still small. Perhaps if one wished to implement a 3x3, 5x5, and 7x7 median filter using a single sorting function. Or perhaps when sorting an arbitrary list of files, when there could be very many or very few items.</p>

<p>In this case, we can utilize a special implementation of <a href="http://en.wikipedia.org/wiki/Bubble_sort">bubble sort</a> that takes advantage of <a href="http://en.wikipedia.org/wiki/Switch_statement#Fallthrough">switch statement fallthrough</a>. To quickly sort sets of size [latex]n \leq 9[/latex], we could use this C code:</p>

<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#define min(a, b) (a &lt; b ? a : b)</span>
<span class="cp">#define max(a, b) (a &gt; b ? a : b)</span>
<span class="cp">#define exch(a, b) temp = a; a = min(temp, b); b = max(temp, b);</span>
<span class="cp">#define exch3(a, b, c) exch(a, b); exch(b, c);</span>
<span class="cp">#define exch4(a,b,c,d) exch3(a,b,c); exch(c,d);</span>
<span class="cp">#define exch5(a,b,c,d,e) exch4(a,b,c,d); exch(d,e);</span>
<span class="cp">#define exch6(a,b,c,d,e,f) exch5(a,b,c,d,e); exch(e,f);</span>
<span class="cp">#define exch7(a,b,c,d,e,f,g) exch6(a,b,c,d,e,f); exch(f,g);</span>
<span class="cp">#define exch8(a,b,c,d,e,f,g,h) exch7(a,b,c,d,e,f,g); exch(g,h);</span>
<span class="cp">#define exch9(a,b,c,d,e,f,g,h,i) exch8(a,b,c,d,e,f,g,h); exch(h,i);</span>



<span class="kt">int</span> <span class="nf">cmpfunc</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">-</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="p">);</span>
<span class="p">}</span>
<span class="c1">// quickly sort an array if size is less than or equal to 9, otherwise use</span>
<span class="c1">// stdlib&#39;s qsort to sort the array.</span>
<span class="kt">void</span> <span class="nf">fallthroughSort</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">9</span>:
     	<span class="n">exch9</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		       <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="p">);</span>
    <span class="k">case</span> <span class="mi">8</span>:
     	<span class="n">exch8</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		       <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="p">);</span>
    <span class="k">case</span> <span class="mi">7</span>:
     	<span class="n">exch7</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		       <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="p">);</span>
    <span class="k">case</span> <span class="mi">6</span>:
     	<span class="n">exch6</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		       <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">);</span>
    <span class="k">case</span> <span class="mi">5</span>:
     	<span class="n">exch5</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">);</span>
    <span class="k">case</span> <span class="mi">4</span>:
     	<span class="n">exch4</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">);</span>
    <span class="k">case</span> <span class="mi">3</span>:
     	<span class="n">exch3</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">);</span>
    <span class="k">case</span> <span class="mi">2</span>:
     	<span class="n">exch</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
     	<span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
     	<span class="n">qsort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">cmpfunc</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Each call to [latex]exchN[/latex] represents a bubble sort pass from index [latex]0[/latex] to index [latex]N[/latex]. Any array that is of size [latex]n \leq 9[/latex] will jump to the proper pass of bubble sort, and execute all the required passes by falling through the switch statement.</p>

<p>You might be skeptical as to how a [latex]O(n^2)[/latex] algorithm is outperforming a [latex]O(n \log n)[/latex] algorithm, but remember that big-O notation only defines asymptotic behavior. It is often the case that the actual performance of an algorithm depends on the constants hidden by big-O notation, as has been <a href="http://stackoverflow.com/questions/7643377/why-is-insertion-sort-faster-than-quick-sort-and-bubble-sort-for-small-cases">exhaustively discussed</a>.</p>

<p>Of course, code similar to that above can be generated for any size, and a Python script to do just that is available in this <a href="https://bitbucket.org/RyanMarcus/fallthrough-sort">BitBucket repository</a>. We’ll take a look at the performance of this algorithm.</p>

<p>The following graph shows the performance of fallthrough sort (for [latex]n \leq 9[/latex]) compared to the standard library’s qsort function. Both functions sorted [latex]10^7[/latex] randomly generated lists of size [latex]n = 9[/latex].</p>

<p><img src="/blog/assets/fallthrough/chart1.png" alt="first chart" /></p>

<p>As you can see, fallthrough sort provides a substantial speed boost. Obviously, the difference is negligible if you’re only sorting one list.</p>

<p>This next graph shows the performance of fallthrough sort (for [latex]n \leq 25[/latex]) compared to the standard library’s qsort function when sorting [latex]10^7[/latex] lists of varying sizes.</p>

<p><img src="/blog/assets/fallthrough/chart2.png" alt="second chart" /></p>

<p>As the number of elements increases, fallthrough sort seems to slow down and approach the speed of qsort (eventually, qsort will become faster). This is expected, given the asymptotic behavior of each algorithm.</p>

<p>This last graph shows how many times faster fallthrough sort is compared to qsort.</p>

<p><img src="/blog/assets/fallthrough/chart3.png" alt="third chart" /></p>

<p>Here, the asymptotic behavior of both algorithms is extremely clear: qsort scales much better than fallthrough sort.</p>

<p>One might consider this comparison unfair because qsort evaluates a user-supplied comparison function. However, looking at the output of GCC reveals that when a very standard function (like the one above) is used, the comparison function is inlined.</p>

<p>One might also consider creating a <a href="http://en.wikipedia.org/wiki/Branch_table">branch table</a> to jump right to the required pass of bubble sort. Once again, looking at optimized GCC output will show that the above switch statement is optimized into a branch table.</p>

<p>You can view a sample implementation and benchmark code over at <a href="https://bitbucket.org/RyanMarcus/fallthrough-sort">BitBucket</a>.</p>

<p><a href="https://plus.google.com/u/0/108417296717615529338/posts/45VYfwK5mjU">Google+ comments</a>.</p>

<p><a href="http://www.reddit.com/r/programming/comments/1hilkn/fallthrough_sort_quickly_sorting_small_sets/">Reddit comments</a>.</p>

<p>Reddit user <a href="http://www.reddit.com/r/programming/comments/1hilkn/fallthrough_sort_quickly_sorting_small_sets/cauvhhp">sltkr seems to be getting better results from a simple insertion sort</a>. This appears to be due to CPU differences, but the discussion is ongoing.</p>


  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/blog/page2">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>

    </div>

  </body>
</html>
